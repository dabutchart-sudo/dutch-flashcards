import { SUPABASE_URL, SUPABASE_ANON_KEY, APP_VERSION } from "./config.js";

const { createClient } = window.supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let allCards = [];
let reviewQueue = [];
let currentIndex = 0;

// ----------------- Utility -----------------

function todayStr() {
  return new Date().toISOString().split("T")[0];
}

function addDays(isoDate, days) {
  const d = new Date(isoDate);
  d.setDate(d.getDate() + days);
  return d.toISOString().split("T")[0];
}

function showToast(msg) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 2500);
}

// ----------------- Settings -----------------

const MAX_NEW_KEY = "maxNewCardsPerDay";

function getMaxNewCardsPerDay() {
  return parseInt(localStorage.getItem(MAX_NEW_KEY) || "10", 10);
}

function setMaxNewCardsPerDay(val) {
  localStorage.setItem(MAX_NEW_KEY, String(val));
}

// ----------------- Navigation -----------------

window.openScreen = function (name) {
  document.querySelectorAll(".screen").forEach((s) => {
    s.classList.remove("visible");
    s.classList.add("hidden");
  });

  const screen = document.getElementById(`${name}-screen`);
  if (screen) {
    screen.classList.add("visible");
    screen.classList.remove("hidden");
  }
};

// ----------------- Summary (Today & Tomorrow) -----------------

function updateSummary() {
  const panel = document.getElementById("summary-panel");
  if (!panel) return;

  const today = todayStr();
  const maxNew = getMaxNewCardsPerDay();
  const tomorrow = addDays(today, 1);

  let dueReviewToday = 0;
  let dueReviewTomorrow = 0;
  let newPool = 0;          // truly new: card_type='new' and first_seen null/undefined
  let introducedToday = 0;  // any card whose first_seen == today

  for (const c of allCards) {
    if (c.suspended) continue;

    const isReviewCard = c.card_type !== "new";

    if (isReviewCard && c.due_date) {
      if (c.due_date <= today) {
        dueReviewToday++;
      }
      if (c.due_date === tomorrow) {
        dueReviewTomorrow++;
      }
    }

    const isTrulyNew =
      c.card_type === "new" &&
      (c.first_seen === null || c.first_seen === undefined);

    if (isTrulyNew) {
      newPool++;
    }

    if (c.first_seen === today) {
      introducedToday++;
    }
  }

  // Today (Option A)
  let availableNewToday = maxNew - introducedToday;
  if (availableNewToday < 0) availableNewToday = 0;
  if (availableNewToday > newPool) availableNewToday = newPool;

  // Tomorrow (Option B): after today's new come from newPool
  const remainingAfterToday = Math.max(0, newPool - availableNewToday);
  let availableNewTomorrow = Math.min(maxNew, remainingAfterToday);

  panel.innerHTML = `
    <h2>Study Summary</h2>
    <div class="summary-row">
      <strong>Today:</strong> ${dueReviewToday} review, ${availableNewToday} new
    </div>
    <div class="summary-row">
      <strong>Tomorrow:</strong> ${dueReviewTomorrow} review, ${availableNewTomorrow} new
    </div>
  `;
}

// ----------------- Data Loading -----------------

async function loadCards() {
  const { data, error } = await supabaseClient
    .from("cards")
    .select("*")
    .order("id");

  if (error) {
    console.error("loadCards error:", error);
    showToast("Error loading cards");
    allCards = [];
    updateSummary();
    return;
  }

  allCards = data || [];
  updateSummary();
}

// ----------------- Build Review Queue (Anki-style) -----------------

function buildReviewQueue() {
  const today = todayStr();
  const maxNew = getMaxNewCardsPerDay();

  const due = [];
  const newCandidates = [];

  for (const c of allCards) {
    if (c.suspended) continue;

    const isDue =
      c.card_type !== "new" &&
      c.due_date &&
      c.due_date <= today;

    const isTrulyNew =
      c.card_type === "new" &&
      (c.first_seen === null || c.first_seen === undefined);

    if (isDue) {
      due.push(c);
    } else if (isTrulyNew) {
      newCandidates.push(c);
    }
  }

  // New cards already introduced today (any card_type)
  const introducedTodayCount = allCards.filter(
    (c) => c.first_seen === today
  ).length;

  let remainingNew = maxNew - introducedTodayCount;
  if (remainingNew < 0) remainingNew = 0;

  // Shuffle helper
  const shuffle = (arr) => {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  };

  shuffle(due);
  shuffle(newCandidates);

  const selectedNew = newCandidates.slice(0, remainingNew);

  reviewQueue = [...due, ...selectedNew];
}

// ----------------- Rendering -----------------

function updateCounter() {
  const el = document.getElementById("review-counter");
  if (!el) return;

  if (!reviewQueue.length) {
    el.textContent = "No cards";
  } else {
    el.textContent = `Card ${currentIndex + 1} of ${reviewQueue.length}`;
  }
}

function renderCurrentCard() {
  const card = reviewQueue[currentIndex];

  const frontText = document.getElementById("card-front-text");
  const backText = document.getElementById("card-back-text");
  const box = document.getElementById("card-box");
  const ratingButtons = document.getElementById("rating-buttons");

  if (!card) {
    frontText.textContent = "No cards to review.";
    backText.textContent = "";
    ratingButtons.classList.add("hidden");
    updateCounter();
    return;
  }

  // Remove flip and clear English to prevent flashes
  box.classList.remove("flip");
  void box.offsetWidth; // force reflow

  frontText.textContent = card.dutch;
  backText.textContent = ""; // English only set when flipped

  ratingButtons.classList.add("hidden");
  updateCounter();
}

// ----------------- Start Review Session -----------------

window.startReviewSession = async function () {
  // Always reload cards so daily limit respects today's progress
  await loadCards();

  buildReviewQueue();

  if (!reviewQueue.length) {
    showToast("No cards available to review.");
    return;
  }

  currentIndex = 0;
  renderCurrentCard();
  openScreen("review");
};

// ----------------- Flip Card -----------------

document.getElementById("card-box").addEventListener("click", () => {
  const card = reviewQueue[currentIndex];
  if (!card) return;

  const box = document.getElementById("card-box");
  const ratingButtons = document.getElementById("rating-buttons");
  const backText = document.getElementById("card-back-text");

  // Fill English only on flip
  backText.textContent = card.english;

  box.classList.toggle("flip");

  if (box.classList.contains("flip")) {
    setTimeout(() => ratingButtons.classList.remove("hidden"), 300);
  } else {
    ratingButtons.classList.add("hidden");
  }
});

// ----------------- Handle Rating -----------------

window.handleRating = async function (rating) {
  const card = reviewQueue[currentIndex];
  if (!card) return;

  const today = todayStr();

  let card_type = card.card_type ?? "new";
  let interval_days = card.interval_days ?? 0;
  let ease = Number(card.ease ?? 2.5);
  let reps = card.reps ?? 0;
  let lapses = card.lapses ?? 0;

  reps++;

  if (card_type === "new") {
    if (rating === "again") interval_days = 1;
    else if (rating === "hard") interval_days = 1;
    else if (rating === "good") interval_days = 3;
    else if (rating === "easy") {
      interval_days = 4;
      ease += 0.15;
    }
    card_type = interval_days > 1 ? "review" : "learning";
  } else if (card_type === "learning") {
    if (rating === "again") {
      interval_days = 1;
    } else {
      interval_days = 3;
      card_type = "review";
    }
  } else {
    // review
    if (rating === "again") {
      lapses++;
      ease = Math.max(1.3, ease - 0.2);
      interval_days = 1;
      card_type = "learning";
    } else if (rating === "hard") {
      ease = Math.max(1.3, ease - 0.15);
      interval_days = Math.round(interval_days * 1.2);
    } else if (rating === "good") {
      interval_days = Math.round(interval_days * ease);
    } else if (rating === "easy") {
      ease += 0.15;
      interval_days = Math.round(interval_days * ease * 1.3);
    }
  }

  interval_days = Math.max(1, interval_days);
  const due_date = addDays(today, interval_days);
  const first_seen = card.first_seen || today; // mark first time we ever rate this card

  const updatePayload = {
    card_type,
    interval_days,
    ease,
    reps,
    lapses,
    first_seen,
    last_reviewed: today,
    due_date,
    suspended: false,
  };

  const { error } = await supabaseClient
    .from("cards")
    .update(updatePayload)
    .eq("id", card.id);

  if (error) {
    console.error("Update failed:", error);
    showToast("Failed to save review");
    return;
  }

  // Move to next card
  currentIndex++;

  if (currentIndex >= reviewQueue.length) {
    showToast("Session complete");
    // Reload cards so summary reflects new due/new counts
    await loadCards();
    openScreen("menu");
    return;
  }

  renderCurrentCard();
};

// ----------------- Word Review -----------------

window.openWordReview = function () {
  const tbody = document.getElementById("word-tbody");
  tbody.innerHTML = "";

  allCards.forEach((r) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${r.dutch}</td>
      <td>${r.english}</td>
      <td>${r.last_reviewed ?? "-"}</td>
      <td>${r.due_date ?? "-"}</td>
    `;
    tbody.appendChild(tr);
  });

  openScreen("wordreview");
};

// ----------------- Reset Learning -----------------

window.resetLearningData = async function () {
  const { data, error } = await supabaseClient.from("cards").select("id");
  if (error) {
    showToast("Error fetching cards to reset");
    return;
  }

  const ids = (data || []).map((r) => r.id);

  const { error: updErr } = await supabaseClient
    .from("cards")
    .update({
      card_type: "new",
      interval_days: 0,
      ease: 2.5,
      reps: 0,
      lapses: 0,
      first_seen: null,
      last_reviewed: null,
      due_date: null,
      suspended: false,
    })
    .in("id", ids);

  if (updErr) {
    console.error("Reset failed:", updErr);
    showToast("Reset failed");
    return;
  }

  showToast("All learning data reset");
  await loadCards();
};

// ----------------- Init -----------------

window.addEventListener("load", async () => {
  // Version display
  const ver = document.getElementById("app-version");
  if (ver) ver.textContent = "Version: " + APP_VERSION;

  // Settings dropdown
  const sel = document.getElementById("max-new-cards-select");
  if (sel) {
    sel.value = String(getMaxNewCardsPerDay());
    sel.addEventListener("change", () => {
      const v = parseInt(sel.value, 10);
      setMaxNewCardsPerDay(v);
      showToast("Max new cards updated");
      updateSummary();
    });
  }

  await loadCards();
  openScreen("menu");
});
